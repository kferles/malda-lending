// SPDX-License-Identifier: UNLICENSED
pragma solidity =0.8.28;

/*
 _____ _____ __    ____  _____ 
|     |  _  |  |  |    \|  _  |
| | | |     |  |__|  |  |     |
|_|_|_|__|__|_____|____/|__|__|   
*/

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";

import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";
import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {ReentrancyGuard} from "@openzeppelin/contracts/utils/ReentrancyGuard.sol";

// contracts
import {IRoles} from "src/interfaces/IRoles.sol";
import {ImTokenGateway} from "src/interfaces/ImTokenGateway.sol";
import {ImTokenOperationTypes} from "src/interfaces/ImToken.sol";

import {mTokenProofDecoderLib} from "src/libraries/mTokenProofDecoderLib.sol";

import {ZkVerifier} from "src/verifier/ZkVerifier.sol";

contract mTokenGateway is Ownable, ZkVerifier, ReentrancyGuard, ImTokenGateway, ImTokenOperationTypes {
    using SafeERC20 for IERC20;

    // ----------- STORAGE -----------
    /**
     * @inheritdoc ImTokenGateway
     */
    IRoles public rolesOperator;

    mapping(OperationType => bool) public paused;

    /**
     * @inheritdoc ImTokenGateway
     */
    address public underlying;

    mapping(address => uint256) public accAmountIn;
    mapping(address => uint256) public accAmountOut;
    mapping(address => mapping(address => bool)) public allowedCallers;

    uint32 private constant LINEA_CHAIN_ID = 59144;

    constructor(address payable _owner, address _underlying, address _roles, address zkVerifier_) Ownable(_owner) {
        require(_underlying != address(0), mTokenGateway_AddressNotValid());
        require(_roles != address(0), mTokenGateway_AddressNotValid());
        require(zkVerifier_ != address(0), mTokenGateway_AddressNotValid());

        underlying = _underlying;

        rolesOperator = IRoles(_roles);

        // Initialize the ZkVerifier
        ZkVerifier.initialize(zkVerifier_);
    }

    modifier notPaused(OperationType _type) {
        require(!paused[_type], mTokenGateway_Paused(_type));
        _;
    }

    // ----------- VIEW ------------
    /**
     * @inheritdoc ImTokenGateway
     */
    function isPaused(OperationType _type) external view returns (bool) {
        return paused[_type];
    }

    /**
     * @inheritdoc ImTokenGateway
     */
    function isCallerAllowed(address sender, address caller) external view returns (bool) {
        return allowedCallers[sender][caller];
    }

    /**
     * @inheritdoc ImTokenGateway
     */
    function getProofData(address user) external view returns (bytes memory) {
        return mTokenProofDecoderLib.encodeJournal(
            user, address(this), accAmountIn[user], accAmountOut[user], uint32(block.chainid), LINEA_CHAIN_ID
        );
    }

    // ----------- OWNER ------------

    /**
     * @inheritdoc ImTokenGateway
     */
    function setPaused(OperationType _type, bool state) external override {
        if (state) {
            require(
                msg.sender == owner() || rolesOperator.isAllowedFor(msg.sender, rolesOperator.GUARDIAN_PAUSE()),
                mTokenGateway_CallerNotAllowed()
            );
        } else {
            require(msg.sender == owner(), mTokenGateway_CallerNotAllowed());
        }
        paused[_type] = state;
    }

    /**
     * @notice Sets the _risc0Verifier address
     * @param _risc0Verifier the new IRiscZeroVerifier address
     */
    function setVerifier(address _risc0Verifier) external onlyOwner {
        _setVerifier(_risc0Verifier);
    }

    /**
     * @notice Sets the image id
     * @param _imageId the new image id
     */
    function setImageId(bytes32 _imageId) external onlyOwner {
        _setImageId(_imageId);
    }

    /**
     * @inheritdoc ImTokenGateway
     */
    function extractForRebalancing(uint256 amount) external nonReentrant {
        if (!rolesOperator.isAllowedFor(msg.sender, rolesOperator.REBALANCER())) revert mTokenGateway_NotRebalancer();
        IERC20(underlying).safeTransfer(msg.sender, amount);
    }

    // ----------- PUBLIC ------------
    /**
     * @inheritdoc ImTokenGateway
     */
    function updateAllowedCallerStatus(address caller, bool status) external override {
        allowedCallers[msg.sender][caller] = status;
        emit AllowedCallerUpdated(msg.sender, caller, status);
    }

    /**
     * @inheritdoc ImTokenGateway
     */
    function supplyOnHost(uint256 amount, bytes4 lineaSelector)
        external
        override
        notPaused(OperationType.AmountIn)
        nonReentrant
    {
        // checks
        require(amount > 0, mTokenGateway_AmountNotValid());

        IERC20(underlying).safeTransferFrom(msg.sender, address(this), amount);

        // effects
        accAmountIn[msg.sender] += amount;

        emit mTokenGateway_Supplied(
            msg.sender,
            accAmountIn[msg.sender],
            accAmountOut[msg.sender],
            amount,
            uint32(block.chainid),
            LINEA_CHAIN_ID,
            lineaSelector
        );
    }

    /**
     * @inheritdoc ImTokenGateway
     */
    function outHere(
        bytes calldata journalData,
        bytes calldata seal,
        uint256 amount,
        address receiver,
        uint256[] calldata journalIndexes
    ) external override notPaused(OperationType.AmountOutHere) {
        // verify received data
        _verifyProof(journalData, seal);

        bytes[] memory journals = mTokenProofDecoderLib.getByJournalIndexes(journalData, journalIndexes);
        uint256 len = journals.length;
        for (uint256 i; i < len;) {
            (address _sender, address _market,, uint256 _accAmountOut, uint32 _chainId, uint32 _dstChainId) =
                mTokenProofDecoderLib.decodeJournal(journals[i]);

            if (_dstChainId != uint32(block.chainid)) {
                _emitSkippedEvent(msg.sender, _sender, receiver, amount, _chainId);
            } else {
                _processValidJournal(_sender, _market, _chainId, _accAmountOut, amount, receiver);
            }

            unchecked {
                ++i;
            }
        }
    }

    // ----------- PRIVATE ------------
    function _processValidJournal(
        address sender,
        address market,
        uint32 chainId,
        uint256 accAmountOutSender,
        uint256 amount,
        address receiver
    ) private {
        // Checks
        _checkSender(msg.sender, sender);
        require(market == address(this), mTokenGateway_AddressNotValid());
        require(chainId == LINEA_CHAIN_ID, mTokenGateway_ChainNotValid()); // Allow only Host
        require(amount > 0, mTokenGateway_AmountNotValid());
        require(accAmountOutSender - accAmountOut[sender] >= amount, mTokenGateway_AmountTooBig());
        require(IERC20(underlying).balanceOf(address(this)) >= amount, mTokenGateway_ReleaseCashNotAvailable());

        accAmountOut[sender] += amount;

        IERC20(underlying).safeTransfer(receiver, amount);

        emit mTokenGateway_Extracted(
            msg.sender,
            sender,
            receiver,
            accAmountIn[sender],
            accAmountOut[sender],
            amount,
            uint32(chainId),
            uint32(block.chainid)
        );
    }

    function _emitSkippedEvent(address executor, address sender, address receiver, uint256 amount, uint32 chainId)
        private
    {
        emit mTokenGateway_Skipped(
            executor,
            sender,
            receiver,
            accAmountIn[sender],
            accAmountOut[sender],
            amount,
            chainId,
            uint32(block.chainid)
        );
    }

    function _verifyProof(bytes calldata journalData, bytes calldata seal) private {
        require(journalData.length > 0, mTokenGateway_JournalNotValid());

        // verify it using the ZkVerifier contract
        _verifyInput(journalData, seal);
    }

    function _checkSender(address msgSender, address srcSender) private view {
        if (msgSender != srcSender) {
            require(
                allowedCallers[srcSender][msgSender]
                    || rolesOperator.isAllowedFor(msgSender, rolesOperator.PROOF_FORWARDER()),
                mTokenGateway_CallerNotAllowed()
            );
        }
    }
}
